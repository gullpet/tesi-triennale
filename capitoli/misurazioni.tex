\chapter{Testing e misurazioni}

Completato lo sviluppo dell'applicazione, ha avuto luogo la fase finale nonché probabilmente la più importante: il testing 
di varie configurazioni e la conseguente raccolta ed analisi dei risultati al fine di valutare i vantaggi e gli svantaggi di 
un porting sul sistema Android.

A differenza del testing su Raspberry Pi, in cui i modelli sono molto standardizzati e distribuiti dallo stesso produttore,
per gli smartphone Android i risultati ottenuti in termini di performance e consumi possono variare anche molto al variare
del dispositivo, a seconda delle caratteristiche tecniche di quest'ultimo.

Per quanto riguarda il seguente progetto, i test sono stati svolti su un dispositivo Android basato sul 
SoC \textit{Qualcomm Snapdragon 730} (sul quale è presente una CPU octa-core).\\
Sono quindi prevedibili risultati 
migliori (perlomeno in termini di prestazioni) rispetto a dispositivi aventi caratteristiche tecniche inferiori.

\section{Testing}

Ai fini del testing sono stati utilizzati fotogrammi precedentemente estratti poiché riprodurre l'intero processo
di acquisizione ed estrazione andrebbe oltre gli scopi limitati del seguente lavoro e aggiungerebbe notevole complessità 
al progetto, costringendo a fare i conti con diversi problemi (ad esempio, la mancanza di \textit{ffmpeg} su Android).
Difatti, nel testare l'applicazione si è considerata esclusivamente la fase di esecuzione, tralasciando le altre tre fasi
presentate in \autoref{sec:ciclo} principalmente per motivi di tempo. L'esecuzione di OTV rappresenta comunque la fase più
importante e con il maggior numero di variabili che possano influenzare le prestazioni e i consumi: le analisi che ne
conseguono sono sicuramente indicative delle potenzialità di un dispositivo.

Il testing è stato eseguito mediante l'ausilio degli strumenti forniti dalla repository GitHub di OTV (\cite{otvgit}),
in particolare gli script Bash adibiti alla creazione dei file di configurazione richiesti per il funzionamento del programma.
Lo script che implementa l'estrazione dei frame a partire da un file video precedentemente acquisito fa uso del programma
\textit{ffmpeg} e salva i fotogrammi estratti all'interno di una cartella \texttt{frames} il cui percorso va specificato.

La cartella dei frames e gli altri file necessari, sono stati quindi prima generati sulla macchina utilizzata per lo sviluppo
dell'applicazione, poi trasferiti sul dispositivo Android mediante l'interfaccia grafica fornita da Android Studio.
Collegando infatti lo smartphone al PC su cui esegue Android Studio è possibile accedere ad una sezione dedicata al file system
del dispositivo.

Come già menzionato, tutti i file di servizio sono stati inseriti all'interno della cartella \texttt{/data/data/\{package\_applicazione\}}
poiché questa fa parte del cosiddetto storage \emph{interno} dell'applicazione, in cui gli accessi non sono vincolati da permessi
richiesti all'utente. Questa cartella inoltre non è accessibile dall'utente se non tramite strumenti esterni al dispositivo 
(come il debugger Android) e può quindi essere utile ad evitare cancellazioni e/o modifiche accidentali dei file necessari.

Particolare attenzione va posta al file \texttt{info\_video.txt}, generato in seguito all'estrazione dei frame. Il file si
presenta nel seguente modo:

\begin{verbatim}
    FPS 25
    Width 715
    Height 540
    FileCount 500
    DirectoryFrame /data/data/gullp.androidotv/frames
    Jump 2
\end{verbatim}

dove il parametro DirectoryFrame rappresenta la directory in cui sono presenti i frame: il file viene letto dall'applicazione
in fase di inizializzazione, quindi è importante che il percorso di tale directory sia accurato.
Tuttavia, essendo il file \texttt{info\_video.txt} generato da uno script eseguito su una macchina differente, è necessario
andare a modificare tale parametro specificando la corrispettiva cartella nel dispositivo Android.

Il processo di testing è avvenuto seguendo un'iterazione di questo tipo:

\begin{enumerate}
    \item Copia delle librerie dinamiche precompilate di OpenCV all'interno del progetto, ottenute con la cross-compilazione 
    e relative a uno specifico set di ottimizzazioni;
    \item Esecuzione dell'applicazione
    \item Ripetizione del punto 3 fino ad ottenere una quantità soddisfacente di risultati
    \item Raccolta e trascrizione dei risultati
    \item Reiterazione a partire dal punto 1 utilizzando una nuova configurazione di OpenCV
\end{enumerate}

\section{Raccolta e analisi dei risultati}

